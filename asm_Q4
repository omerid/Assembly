INCLUDE Irvine32.inc

N=7
.data
L=4
R=8
b word N
Arr word 7, 8, 13, 16,10, 11, 12
DiffArr word N dup(?)

count			dword 0
pivot			dword ?
index_j			dword ?
index_i			dword ?
newChoose		dword ?
newpivotindex	dword ?

.code
my_main PROC

    call	randomize
    push	offset arr
    push	0
    push	6
    call	QSort
	mov		edx, offset arr
	call	printArr 
    call	exitProcess

my_main ENDP

;------------------------------------------------------------

; print the arr 
printArr PROC

	xor		eax, eax 
	xor		ebx, ebx
	xor		ecx, ecx
	mov		ecx, lengthof arr

printA:
	mov	ax, word ptr [edx+ebx]
	call	WriteDec
	call	crlf
	add		ebx, 2
	loop printA

printArr ENDP

;------------------------------------------------------------

Collatz PROC
	push	ebp
	mov		ebp, esp
    mov     eax, dword ptr [ebp + 8]
    shr     eax, 1 ;check if even or not
    jnc     EvenNum ;if even
	jmp		OddNum ;else
	jmp     EndCollatz

OddNum:
    cmp     dword ptr [ebp + 8], 1 ;checking the stop conditions
    je      EndCollatz  
    mov     eax, dword ptr [ebp + 8]    
    mov     ecx, 3
    mul     ecx
    inc     eax
    inc     Count
    push    eax
    call    Collatz
    jmp     EndCollatz
	
EvenNum:
    cmp     dword ptr [ebp + 8], 1 ; checking the stop conditions
    je      EndCollatz
    mov     eax, dword ptr [ebp + 8]
    mov     ecx, 2      
    xor     edx, edx
    div     ecx
    inc     Count
    push    eax
    call    Collatz
    

EndCollatz:
    mov		eax, Count
    mov		esp, ebp
    pop		ebp
    ret		4

Collatz ENDP

;------------------------------------------------------------

ChooseIndex Proc 
    push	ebp
    mov		ebp, esp
    push	edx
    mov		eax, [ebp+12] ; para right
    mov		edx, [ebp+8] ; para left
    sub		eax, edx
    sub		eax, 1
    cmp		eax, 0
    je		donechooswindex
    call	RandomRange

donechooswindex:

	pop		edx ; WE DIDNET DO IT
    mov		esp, ebp
    pop		ebp
    ret		8
ChooseIndex ENDP

;------------------------------------------------------------

Partition PROC
    push	ebp
    mov		ebp, esp
    push	ecx
    push	edx
    push	ebx
    
    mov		edx, [ebp+20] ;address of Arr
    mov		ebx, [ebp+16] ;index Left
    mov		ecx, [ebp+12] ;index Right
    mov		eax, [ebp+8] ;pivot

	;for relative location in arr
	shl		ebx, 1
	add		edx, ebx
	shr		ebx, 1

    ;for looping 
    sub		ecx, ebx
    inc		ecx

    mov		index_j, 0 ; 
    mov		index_i, 0 ; 
    sub		index_i, 2 ; low-1

	;moving to the right place in the arr and taking the arr[i]
    shl		eax, 1 ; shifing left becuase the arr is word arr
	mov		pivot, eax
	mov		ax, word ptr [edx+eax]

Ploop: 
    mov		esi, edx
    add		esi, index_j

    mov		edi, 0 ; reset the var 
    mov		di, word ptr [esi]
	;cmp	di, word ptr [eax]
    cmp		di, ax
    jae		continueL
    add		index_i, 2

    ;push	eax and ecx for saving them before the swap
    push	eax
    push	ecx
    xor		eax, eax
    xor		ecx, ecx

    ;beacuse lea dosent work with vars we save ebx and use him to reach the right index
    ;----------------------------------
    push	ebx
    xor		ebx, ebx
    mov		ebx, index_i
    lea		eax, [edx + [ebx]]
    push	eax

    ;----------------------------------
    xor		ebx, ebx
    mov		ebx, index_j
    lea		ecx, [edx + [ebx]]
    push	ecx
    call	Swap

    pop		ebx
    pop		ecx
    pop		eax
	add		index_j, 2
    loop	Ploop
    Jmp		DonePartition

continueL:
    add		index_j, 2
    loop	Ploop

DonePartition:

    add		index_i, 2
    xor		ecx, ecx
    xor		ebx, ebx

    mov		ebx, index_i
    lea		ecx, [edx + [ebx]]
    push	ecx

	xor		ecx, ecx
    xor		ebx, ebx

;----------------------------------
	mov		ebx, [ebp+16] ;index Left
    mov		ecx, [ebp+12] ;index Right
	sub		ecx, ebx
	inc		ecx ; WE FORGET IT

findPivotIndex:
	
	shl		ecx, 1
	cmp		ax, [edx+ecx]
	je		contine
	shr		ecx, 1
	loop	findPivotIndex

;----------------------------------

contine:

    lea		ecx, [edx + [ecx]]
    push	ecx
    call	Swap
    
	mov		edx, [ebp+20] ;address of Arr - ++++++ I ADDED IT ! 150121-22:13
    mov		ecx, lengthof arr

findPivotIndexLast:
	
	shl		ecx, 1
	cmp		ax, [edx+ecx]
	je		DoneDone
	shr		ecx, 1
	loop	findPivotIndexLast

DoneDone:
    shr		ecx, 1
    mov		eax, ecx ; return the pivot index

    ;pop		eax ;WE CANT DO IT. WE NEED EAX ABOVE ^^^
    pop		ebx
    pop		edx
    pop		ecx
    mov		esp, ebp
    pop		ebp
    ret		16
Partition ENDP

;------------------------------------------------------------

SWAP PROC
    push	ebp
    mov		ebp, esp
 
    sub		esp, 4         ; reserve memory for a local variable at [EBP-4]

    push	eax
    push	ebx
    push	edx

    xor		eax, eax
    xor		ebx, ebx
    xor		edx, edx

    mov		ebx, [ebp+12]		
    mov		ax, WORD ptr [ebx]    
    mov		word ptr [ebp-4], ax   
    mov		edx, [ebp+8]         

    mov		ax, WORD ptr [edx]     
    mov		word ptr [ebx], ax   
    mov		ax, word ptr [ebp-4]
    mov		word ptr [edx], ax    
    
    pop		edx
    pop		ebx
    pop		eax
    mov		esp, ebp
    pop		ebp
    ret		8
    
SWAP ENDP

;------------------------------------------------------------

QSort PROC
    push	ebp
    mov		ebp ,esp
    sub		esp ,8 ; first 4 bytes for choose index, second 4 bytes for newpivotindex
    push	ecx
    push	edx
    push	ebx
    mov		ebx, [ebp + 16] ; Arr offset
    mov		edx, [ebp + 12] ; Left
    mov		ecx, [ebp +8] ;Right

    cmp		dx, cx
    jge		DoneQsort

    push	ecx ; push right
    push	edx ; push Left
    call	ChooseIndex ; the return call is in ax
    mov		[ebp-4], eax 

    push	ebx ; the address of the arr
    push	edx ; push left
    push	ecx ; push right
    push	[ebp-4] ; push pivot index that returned from Chooseindex
    call	partition 
    mov		[ebp-8], eax 

    push	ebx ; the address of the arr
    push	edx ; push left

;------------------------------------

    push	ecx
    mov		ecx,[ebp-8]
    mov		newpivotindex, ecx
    sub		newpivotindex ,1
    pop		ecx

;-------------------------------------

    push	newpivotindex ; push new pivot index
    call	Qsort

    push	ebx ; the address of the arr

;------------------------------------

    push	ecx
    mov		ecx,[ebp-8]
    mov		newpivotindex, ecx
    add		newpivotindex ,1
    pop		ecx
    ;-------------------------------------
    push	newpivotindex ; push new pivot index
    push	ecx ; push right
    call	Qsort

DoneQsort:
    pop		ebx
    pop		edx
    pop		ecx
    mov		esp, ebp
    pop		ebp
    ret		12
QSort ENDP

;------------------------------------------------------------

END my_main
